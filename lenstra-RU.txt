# copy-paste from translate.google.com

Прежде чем перейти к следующему алгоритму уменьшения коэффициента
простого числа, важно объяснять некоторые математические понятия
и алгоритмы, лежащие в основе операций между числами, состоящие из многих цифр.
N.B. Это всего лишь базовые и очень простые объяснения, которые вы должны понять,
чтобы получить представление о понятиях, которые требуются в
математико-компьютерной статье. Для полного просмотра этих читать математические тексты и алгоритмы.
Пожалуйста, помните, что математика очень важна, если вы хотите погрузиться в сферу криптографии.
Реализации алгоритмов, представленных в этой статье можно легко найти в любой математической
библиотеке для любой язык программирования.

0] Используемые обозначения

1] Основные концепции

1.1] Математика
1.1.1] Алгебраические структуры
1.1.2] Группа
1.1.3] Кольцо
1.1.4] Поле
1.1.5] Модульная арифметика
1.1.6] Малая теорема Ферма

1.2] Информационные технологии
1.2.1] Вычислимость и сложность алгоритма
1.2.2] Числовое представление сообщения
1.2.3] Представление сообщения в Zn

2] Основные алгоритмы
2.1] Тест на простоту и теорема Ферма.
2.1.1] Вероятностный тест на простоту
2.2] Случайные числа
2.2.1] Линейный конгруэнтный метод
2.3] Наибольший общий делитель НОД

3] Метод эллиптических кривых 


0] Используемые обозначения
+ Сумма
- Вычитание
/ Разделение
* Умножение
^ Возведение в степень
% Остальное подразделение модуль мода
= Назначение
== Равенство
> Больше
< Меньше
>= Больше или равно
<= Меньше или равно
/= Не равны
|x| Абсолютное значение x
° Оператор композиции
[A1..Ax] Элементы с 1 по x
=> Тогда
<=> Если и только если
@ Для каждого
И членство
t.c. Такой, что
-] Существуют
idA Identity в A
log (n) Логарифм числа n по основанию два.
Log (n) десятичный логарифм числа n
lim (x -> + inf) f (x) предел для x, который стремится к большей бесконечности, чем f (x)
НОД (a, b) Наибольший общий делитель между a и b
НОК (a, b) Наименьшее общее кратное между a и b 

1] Основные концепции
В этом разделе мы объясним некоторые понятния в очень простой форме.

1.1.1] Алгебраические структуры
Для набора A внутренняя бинарная операция - это закон, который на каждой
паре декартова произведения AxA однозначно соответствует
элемент А.

1.1.2] Группа
Группа (G, *) имеет внутреннюю операцию * и представляет собой набор, который
соответствует свойствам:
- ассоциативное свойство P @ a, b, c E G, (a * b) * c == a * (b * c)
-содержит нейтральный элемент @ a E G, uG * a == a * uG == a [где uG - нейтральный элемент]
-имеет обратное @ a E G, -] b E G t.c. а * b == b * a = uG

Для группы (G, *), если a * b == b * a, @ a, b E G, то G является коммутативной группой или абелевой группой. 

1.1.3] Кольцо
Кольцо (A, +, *) имеет две внутренние операции, одна из которых аддитивно обозначается
а другой - мультипликативно; кольца бывают:
-абелева группа относительно суммы [первая операция]
-продукт [вторая операция] имеет ассоциативную собственность
-распределительное свойство a * (b + c) == a * b + a * c; (a + b) * c == a * c + b * c

Кольцо называется коммутативным, если произведение [вторая операция] удовлетворяет
коммутативности. Если есть элемент, нейтральный по отношению к произведенное тогда кольцо имеет личность.

1.1.4] Поле
Поле (C, +, *) имеет две внутренние операции, как и в случае кольца
один обозначается аддитивно, а другой обозначается умножением.
-C - мультипликативная группа.
- вторая операция является распределительной по отношению к первой. 

1.1.5] Модульная арифметика
Модульная арифметика изучает остатки арифметических делений.
X - делитель, m - делитель, Q - частное, а R - остаток.
(X mod m) = R считывает, что X по модулю m равно R.
Примеры:
 5 mod  3 =  2 на самом деле m * Q + R == X -> 3 * 1 + 2 == 5
31 mod 43 = 31 на самом деле 43 * 0 + 31 == 31

Можно сказать, что R < m, на самом деле 0 < R < m-1

(X mod 1) == 0 -> любое число по модулю 1 всегда равно 0.
(0 mod m) == 0 -> 0 по модулю любое число всегда равно 0.
(X + Y) (mod m) == X (mod m) + Y (mod m) -> остаток суммы равенравняется сумме остатков.
(X * Y) (mod m) == X (mod m) * Y (mod m) -> остальная часть продукта
равняется произведению остатков. Эта последняя эквивалентность будет нам полезна
при определении остатков от делений между числами, состоящими из
много цифр, поскольку это говорит нам, что:
(X ^ 2) (mod m) == X (mod m) * X (mod m) == R ^ 2

1.1.6] Малая теорема Ферма
О чем говорит нам маленькая теорема Ферма?
p делит a ^ (p - 1) - 1, когда p простое, а a простое с p [у них нет общих делителей].
Из этой формы можно сделать следующее обобщение: я беру два
положительные целые числа m, n с m == n, тогда a ^ n == a ^ m (mod p).
[Используется для демонстрации алгоритма RSA].

1.1.5] Модульная арифметика
Модульная арифметика изучает остатки арифметических делений.
X - делитель, m - делитель, Q - частное, а R - остаток.
(X mod m) = R считывает, что X по модулю m равно R.
Примеры:
5 mod 3 = 2 на самом деле m * Q + R == X -> 3 * 1 + 2 == 5
31 мод 43 = 31 на самом деле 43 * 0 + 31 == 31

Можно сказать, что R <m, на самом деле 0 <R <m - 1

(X mod 1) == 0 -> любое число по модулю 1 всегда равно 0.
(0 mod m) == 0 -> 0 по модулю любое число всегда равно 0.
(X + Y) (mod m) == X (mod m) + Y (mod m) -> остаток суммы равен
равняется сумме остатков.
(X * Y) (mod m) == X (mod m) * Y (mod m) -> остальная часть продукта
равняется произведению остатков. Эта последняя эквивалентность будет нам полезна.
при определении остатков от делений между числами, состоящими из
много цифр, поскольку это говорит нам, что:
(X ^ 2) (mod m) == X (mod m) * X (mod m) == R ^ 2

1.1.6] Малая теорема Ферма.
О чем говорит нам маленькая теорема Ферма?
p делит a ^ (p - 1) - 1, когда p простое, а a простое с p [у них нет
общие делители].
Из этой формы можно сделать следующее обобщение: я беру два
положительные целые числа m, n с m == n, тогда a ^ n == a ^ m (mod p).
[Используется для демонстрации алгоритма RSA]. 

1.2] Информационные технологии

1.2.1] Вычислимость и сложность алгоритма
Вычислимость: можно написать алгоритм для решения проблемы?

Сложность: зная, что проблема вычислима, сколько стоит сложность?
Для оценки сложности нас интересует время вычисление (поэтому мы
опускаем занимаемое пространство памяти). Сложность рассчитывается с учетом 
всех операций - алгебраические и логические, доступ для чтения и записи и т. д.
Однако в наших оценках мы будем предполагать, что машина, которая будет выполнять 
алгоритм, будет идеальной машиной, абстрактный компьютер, не учитывающий 
производительность оборудования. Чтобы описать сложность алгоритма, необходимо
знать порядки величин: тета, омега, О.
Теперь возьмем две функции f и g, скажем так:
- f равно O(g), если f растет так же, как g, поэтому g - верхний предел.
- f является омега (g), если f растет как минимум как g, то g является пределомнизший.
- f является theta (g), если f растет как g, поэтому f имеет тот же порядок, что и размер g.
По понятию предела lim (x -> + inf) f (x) / g (x) == c
Если c /= 0 => f является theta (g) и, следовательно, g является theta (f)
Если c == 0 => f равно O (g)

Примером может быть: алгоритм имеет сложность O (log n),
это означает, что он имеет логарифмическую базу 2 сложности n.

В алгоритмах может быть доминирующая инструкция, тогда бывает, что
уменьшая сложность этого, сложность всего алгоритм резко падает.

Лучший способ оценить сложность кода - это
разбить его на блоки и проанализировать порядок каждого блока.

Пример расчета сложности:
{
   int n, i, p;
   scanf ("%d", & n);
   for(i = 0, р = 0; i < п; i++) {р++; }
}
Сложность этого блока O(n). Это может вырасти
вставкой новой операции большей сложности.

1.2.2] Числовое представление сообщения
N.B. ДАННЫЙ ПУНКТ И ПЕРВЫЙ О ПРЕДСТАВЛЕНИИ ЧИСЕЛ В Zn.
имеют решающее значение для понимания большей части
алгоритма шифрования.

Например, предположим, что сообщение состоит только из 21ой.
буквы итальянского алфавита плюс пробел. Итак, с числами
от 0 до 21 мы можем указать любой символ.
Учитывая m блоков, сколько блоков мы можем закодировать с помощью наших
набор из 22 символов? 22^m; так что мы можем указать каждый блок
определяя его между 0 и (22^m)-1.
Возьмем для примера блок [A1..Am], обозначим цифрами
[X1..Xm], соответствующие буквам A1..Am, и мы указываем блок
с полученным числом.
Более точно с помощью метода, проиллюстрированного ниже, мы получаем, что каждый
блок указывается однозначно:
x = 22^(m-1) * X1 + 22^(m-2) * X2 + ... + 22^1 * X (m-1) + Xm
Очевидно, что процесс обратим, на самом деле мы можем получить
[X1..Xm], а затем [A1..Am]. Давайте возьмем наш x и разделим его на 22,
остаток, полученный от этого деления, будет Xm. Теперь разделим
частное (Q) деления на 22, и мы получаем X(m-1) и так далее.  

1.2.3] Представление сообщения в Zn
N.B. ДАННЫЙ ПАРАГРАФ ЯВЛЯЕТСЯ ОСНОВНЫМ ДЛЯ ПОНИМАНИЯ АЛГОРИТМА КРИПТОГРАФИИ.
[Этот абзац частично представляет собой упрощенное резюме ссылки 2]
[В этом абзаце нужна модульная арифметическая часть]
Как только мы нашли количество символов в нашем алфавите (22 в
предыдущем абзаце), как правило, n, мы можем обозначить Zn
набор чисел от 0 до n-1. Отсюда мы можем написать функцию f:Zn -> Zn, которая в 
каждом блоке из m символов Zn связывает новый блок в Zn; этот процесс делает возможным
обратная операция (описание) f^-1.
Необходимым условием обратимости функции f является то, что
является инъективным, то есть с каждым элементом домена он связывает один и
только одно изображение; если условие не было необходимым, то
мы не могли написать функцию, которая однозначно расшифровывает блоки.
Математически функция называется инъективной, если:
f (x) == f (x') <=> x == x'

Функция f обратима тогда и только тогда, когда она инъективна.

Условие обратимости выражается так:
Взяв два элемента x E X, y E Y, пусть f - функция от X до Y,
тогда существует функция f^-1 от Y до X тогда и только тогда, когда
f^-1(f(x)) = x и f(f^-1(y)) = y
Обратимость также можно записать так:
g ° f = idA и f ° g = idB
[Обычно: f ° g == f(g)] 

** ЭКВИВАЛЕНТНОСТЬ **
Теперь определим оператор эквивалентности или сопряжения в Zn
а == b (mod n).
Проще говоря, если мы думаем о Zn как о наборе
последовательных чисел, берем два числа a, b E Zn.

** СУММА **
Если a + b < n, то мы можем взять сумму как результат а + b.
Если a + b >= n, то мы должны вычесть n, так как мы промахнемся
из множества Zn, так как мы должны рассматривать числа больше n
что не может быть внутри целого.
Итак, если мы вспомним эквивалентность как n+1 == 1 в Zn, n+2 == 2 в Zn и т.п.
Операция редукции выполняется для перехода от общего числа своему корреспонденту в Zn.
Пример:
3 + 5 == 2 в Z6, так как 8 (mod 6) == 2

**ПРОДУКТ**
Очевидно, что все, что мы сказали до сих пор, стоит того. То же самое и для умножения.
a * b = c (mod n)

**НАПРОТИВ**
Каждый x E Zn допускает противоположное, которое является просто конгруэнтным числом
a -x в Zn, так что x + (-x) == 0, поскольку 0 - нейтральный элемент суммы.
Пример:
В Z8 число, обратное 5, равно 3, фактически 5 + 3 == 8 == 0

**ОБЕСПЕЧИТЬ РЕГРЕСС**
Что касается обратного, мы должны обратиться к нейтральному элементу
продукт, которого равен 1, на самом деле x * x^-1 == 1.
Поэтому не все элементы Zn допускают инверсию. Возьмем объявление
пример в Z5 цифра 2; его обратное значение будет 3, так как
2 * 3 == 6 == 1.
В то время как 2 не имеет обратного в Z6, так как каждое число умножается на 2
возвращает четное число, а обратное должно быть нечетным.
В общем, мы можем резюмировать, что число имеет обратное по Zn тогда и только тогда, когда НОД (x, n) == 1.
Следовательно, если n простое (т.е. делится только на единицу и само себя), 
то любое число, кроме 0, допускает обратное, и Zn определены
эти операции суммы и произведения представляют собой поле; наоборот, если
n не является простым, в Zn есть хотя бы одно число, не имеющее обратного с
Zn - кольцо.

2] Основные алгоритмы
Какие характеристики должен иметь алгоритм?
a) Завершено: оно должно заканчиваться после конечного числа шагов.
b) Определено: поскольку компьютеры являются детерминированными машинами, каждый
шаг алгоритма должен быть точно определен.
c) Ввод: 0 или более входных значений.
d) Выход: 1 или несколько выходов.
e) Осуществимость: все операции, используемые в алгоритме, должны
быть осуществимым даже человеком на бумаге.

Алгоритм называется вычислительно управляемым, если существует эффективный алгоритм ее решения.
Алгоритм считается эффективным, если есть функция, которая его ограничивает.

2.1] Тест на простоту и теорема Ферма
Согласно теореме Ферма, x^(p-1) mod p == 1
если p простое и x не делится на p; когда эти отношения не проверено, то p составлен.
Следовательно, для проверки правильности требуется только O (log n) умножений по модулю n.
Теорема Ферма. Однако для очень больших n вычисления становятся
очень дорого по времени и ресурсам.

2.1.1] Вероятностный тест на простоту
Вероятностный тест на простоту p является фундаментальным для
скорости и в любом случае надежно проверить, является ли целое число
простое или составное (и, следовательно, сводимое в простые множители :)).
0] Возьмем нечетное n целое число
(очевидно, что если оно четное, то у него будет хотя бы один фактор, 2);
1] Пусть n = 1 + (2^k) * q
(q будет нечетным)
2] Выберем случайный x такой, что 1 < x < n
3] Пусть j = 0 и y = (x ^ q) mod n.
(этот расчет требует O (log q) шагов)
4] Если j == 0 и y == 1, или y == n-1, тогда n, вероятно, простое число.
Если j > 0 и y == 1, мы переходим к шагу 6.
В противном случае продолжаем.
5] j = j + 1
Если j < k, тогда y = (y ^ 2) mod n, и мы возвращаемся к шагу 4.
В противном случае продолжаем.
6] p определенно составлен.

Сам алгоритм, рассчитанный за один раз, имеет четную вероятность
до 1/4 неудачи; для большей безопасности можно
повторить алгоритм r раз, чтобы вероятность отказа
оба из (1/4) ^ r. Поэтому мы думаем повторить алгоритм несколько раз.
конечное время, например 100, вероятность того, что наш
сбой алгоритма будет (1/4) ^ 100, практически 0.

[Этот тест является самым популярным и применяется во всех
математические библиотеки (см., например, GNU Multi Precision и библиотеку
OpenSSL math) из-за того, что он быстрый и надежный.]  


2.2] Случайные числа
Случайное число - это число, выбранное случайным образом; написать алгоритм
найти хороший источник простых чисел совсем не просто.
Такие алгоритмы, как генератор суперслучайных чисел, устарели и
они очень быстро сходятся, и это учит нас, как генерировать
случайные числа, вы не должны использовать случайные методы, но вместо этого вы должны
основываться на математической теории.
Источником случайных чисел в системах GNU / Linux является /dev/random.
В C мы можем получить случайные числа, достаточно наклонить
к двум функциям, содержащимся в stdlib, которые являются srand(), что позволяет
чтобы установить случайное seed и srand(), который дает нам целое число
случайный от 0 до RAND_MAX.
#define RAND_MAX 2147483647
Очевидно, что последовательность случайных чисел можно получить повторно, повторно введя
то же seed в srand().
Примером инициализации может быть srand(time(NULL));.

2.2.1] Линейный конгруэнтный метод
Для генерации случайных чисел, равномерно распределенных между 0 и 1 да
в основном он использует линейный конгенциальный метод.
В этом документе я только показываю идею алгоритма.
Выберите 4 числа:
m модуль t.c m > 0
множитель t.c 0 <= a < m
c приращение t.c 0 <= c < m
Начальное значение Xo t.c 0 <= Xo < m

За последовательностью случайных чисел Xn последуют:
X(n + 1) = (a * Xn + c) mod m
(п >= 0)
Очевидно, есть способы выбрать 4 стартовых номера.
они позволяют нам выбирать хорошие случайности.

2.3] Наибольший общий делитель НОД
[GCD == Great Commin Divisor]
В этом разделе мы выйдем за пределы математического аспекта наиболее распространенных
делитель также алгоритм расчета.
Для двух чисел a, b наибольший общий делитель НОД (a, b) равен числу плюс
большой, что разделяет их обоих. Давайте теперь посмотрим на некоторые свойства GCD.
НОД (0, 0) == 0
НОД (u, v) == GCD (v, u)
НОД (u, v) == GCD (-u, v)
НОД (u, 0) == |u|

Алгоритм Евклида позволяет найти наибольший общий делитель
без предварительного нахождения простых делителей u и v.
Мы всегда помещаем старшее целое число слева.

Давайте сначала посмотрим на исходный алгоритм:
0] Пусть A и C - два целых числа > 1, вычислить НОД.
1] Если A > C и C делят A => C, это НОД (A, C)
2] (A mod C) == 1, то A и C простые среди них, поэтому
   алгоритм заканчивается. В противном случае (A mod C) > 1, мы вычисляем
   НОД (C, A mod C).
Таким образом, этот алгоритм дает жизнь рекурсивной процедуре.

Вместо этого мы видим современную реализацию алгоритма.
0] Пусть u и v - два целых числа >= 0, вычислить НОД (u, v)
1] Если v == 0, то НОД (u, v) == u
2] r = u mod v, u = v, v = r; возвращаемся к пункту 1].

Существуют и другие алгоритмы вычисления НОД [например, двоичный НОД
алгоритм], и поэтому мы могли бы продолжить разговор о максимальном
общий разделитель для страниц и страниц, но я бы сказал, чтобы передать идею
двух описанных более чем достаточно.

3] Метод эллиптических кривых

Идея алгоритма Lenstra заключается в следующем:
воспользоваться эллиптическими кривыми, выбранными случайным образом, для выполнения
попыток факторинга, и каждая из них имеет вероятность
нет ничего, чтобы найти простой делитель N.
Сначала давайте посмотрим, как создается эллиптическая кривая, уравнение которой
е': y^2 = x^3 + a*x + b
Из этого мы можем вывести, что эллиптическая кривая является графиком
кубическая (третья степень) [не следует путать с эллипсом].
Эллиптические кривые - это непрерывные функции, которые позволяют нам
строить бинарные операции между различными точками модели
естественная геометрия, которая превращает множество точек в группу абелевской.
ЭК могут быть определены в любом поле k.
Алгоритм является усовершенствованием алгоритма Полларда p-1 и был
самый быстрый способ сначала найти простые множители целого числа
сита обобщенного числового поля. Однако это все еще алгоритм
быстрее для целых чисел меньше 64 бит [20 цифр].
Улучшение состоит в том, что Lenstra
рассматривает группу случайной эллиптической кривой над конечным полем
Zp [с простым p], который всегда имеет порядок p-1. Вместо этого порядок
группы ЭК на Zp случайным образом изменяется от p до 2p.   

0]
Пусть n будет нашим простым числом.

1]
Выберем эллиптическую кривую C: y^2 = x^3 + a*x + b, такую, что a и b
принадлежат Z (множеству целых чисел).
Затем мы выбираем точку P(x, y).
И выбор C, и выбор P должны быть псевдослучайными.
[Если мы потерпим неудачу попытку факторизации с парой (C, P)
выбор теперь мы должны выбрать другой случайным образом.]

2]
Теперь проверим, что наибольший общий делитель НОД (4a^3 + 27b^2, n) == 1
Если это условие верно, у нас есть подтверждение, что оно исходит от нас.
выбор сводится по модулю p. Это означает, что, взяв первый p,
можно рассматривать коэффициенты уравнения кривой по модулю p
тогда и только тогда, когда они просты с p.
[GCD(K, Z) читается как наибольший общий делитель между K и Z]
Если 1 < НОД(4a^3 + 27b^2, n) < n, то мы нашли неделитель
тривиально от n, поэтому мы нашли простой делитель n. В любое время
что это условие выполняется, мы можем разделить n на множитель
нашли и продолжаем разложение на простые множители.
Если, с другой стороны, мы обнаружим, что результат наибольшего общего делителя равен
равно n, то мы должны сгенерировать новую пару (C, P).

3]
Возьмем такое целое число k, чтобы оно было произведением всех i
простые числа меньше некоторых случайно выбранных b.
Для облегчения расчетных операций мы предполагаем, что b меньше
в беззнаковое 4-байтовое целое число.
Теперь достаточно найти все младшие простые числа этого b e
умножьте их так, чтобы k было кратно каждому из них.
Вычислить kP в группе методом быстрых степеней по модулю n.
kP - это нуль эллиптической кривой в группе Zp [где p -
простой делитель числа n], но он не является нулем в группе Zq [где q -
другой делитель n, где q /= p]. На этом этапе мы можем найти
коэффициент n вычисления НОД(xP, n) [где xP - первая координата точки P].

4] Если процедура не удалась, необходимо начать заново с новой.
пара (C, P).

Достойной реализацией алгоритма является gmp-ecm Пола Циммермана.
и Александр Крупа.
[Код реализации метода простой эллиптической кривой (SECMI), который
найдено на моем сайте - это простая реализация написанного
Рихарда Брента, у которого были проблемы с некоторыми числами, и это могло быть
ускоренный].

Для любых разъяснений напишите мне на paolo.ardoino@gmail.com
Привет

Рекомендации:
* 1 - Искусство программирования Том 1-2
* 2 - Заметки по криптографии Джованни Альберти
* 3 - Различные книги по математике и заметки 
